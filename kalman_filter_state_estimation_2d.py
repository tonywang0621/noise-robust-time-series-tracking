# -*- coding: utf-8 -*-
"""kalman_filter_state_estimation_2D.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ypm0NIWQbV1DhZDelvWC1URSLHV5sllh
"""

import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression

# (1) 設定參數
T = 200
dt = 1.0
seed = 42
np.random.seed(seed)

# (2) 系統雜訊 Q 與量測雜訊 R
q_pos = 0.2       # 位置的系統擾動強度
q_vel = 1.0       # 速度的系統擾動強度
r_meas = 4.0      # 量測噪音 variance (位置量測)

Q = np.diag([q_pos, q_vel])         # (2x2)
R = np.array([[r_meas]])            # (1x1)

# (3) 狀態轉移矩陣 F 與觀測矩陣 H
F = np.array([[1.0, dt],
              [0.0, 1.0]])          # (2x2)
H = np.array([[1.0, 0.0]])          # (1x2)

# (4) 初始真實狀態
x0_true = np.array([0.0, 1.0])      # [p0, v0]

# (5) 生成隱藏狀態 x_t = [p_t, v_t]^T
x = np.zeros((T, 2))
x[0] = x0_true
w = np.random.multivariate_normal(mean=[0.0, 0.0], cov=Q, size=T)
for t in range(1, T):
    x[t] = F @ x[t-1] + w[t-1]

p_true = x[:, 0]
v_true = x[:, 1]

# (6) 生成觀測 y_t
v_meas = np.random.normal(loc=0.0, scale=np.sqrt(r_meas), size=T)
y = (H @ x.T).flatten() + v_meas

# (7) Baseline 1: Naive
p_hat_naive = y.copy()

# (8) Baseline 2: Moving Average
def moving_average(y, k):
    y = np.asarray(y)
    out = np.zeros_like(y, dtype=float)
    for t in range(len(y)):
        out[t] = np.mean(y[max(0, t-k+1):t+1])
    return out

k = 5
p_hat_ma = moving_average(y, k)

# (9) Baseline 3: Linear Regression
def build_regression_data_1d(y, p_true, k):
    X, target = [], []
    for t in range(k, len(y)):
        X.append(y[t-k:t][::-1])
        target.append(p_true[t])
    return np.array(X), np.array(target)

X_reg, y_reg = build_regression_data_1d(y, p_true, k)
model = LinearRegression()
model.fit(X_reg, y_reg)

p_hat_reg = np.zeros_like(p_true, dtype=float)
p_hat_reg[:k] = np.nan
p_hat_reg[k:] = model.predict(X_reg)

# (10) 2D Kalman Filter
def kalman_filter_2d_posvel(y, F, H, Q, R, x0_hat=None, P0=None):
    T = len(y)
    x_hat = np.zeros((T, 2))
    P = np.zeros((T, 2, 2))
    K_hist = np.zeros((T, 2, 1))

    if x0_hat is None:
        x_hat[0] = np.array([y[0], 0.0])
    else:
        x_hat[0] = x0_hat

    if P0 is None:
        P[0] = np.diag([10.0, 10.0])
    else:
        P[0] = P0

    for t in range(1, T):
        # Prediction
        x_pred = F @ x_hat[t-1]
        P_pred = F @ P[t-1] @ F.T + Q

        # Update
        innov = np.array([y[t]]) - (H @ x_pred.reshape(-1,1)).flatten()
        S = H @ P_pred @ H.T + R
        K = P_pred @ H.T @ np.linalg.inv(S)

        x_hat[t] = x_pred + (K.flatten() * innov[0])
        P[t] = (np.eye(2) - K @ H) @ P_pred
        K_hist[t] = K

    return x_hat, P, K_hist

x_hat_kf, P_kf, K_kf = kalman_filter_2d_posvel(y, F, H, Q, R)
p_hat_kf = x_hat_kf[:, 0]
v_hat_kf = x_hat_kf[:, 1]

# (11) 評估指標 (RMSE, MAE)
def rmse(a, b):
    return np.sqrt(np.mean((np.asarray(a) - np.asarray(b)) ** 2))

def mae(a, b):
    return np.mean(np.abs(np.asarray(a) - np.asarray(b)))

valid = ~np.isnan(p_hat_reg)
print("Evaluation on t >= k\n")
print("Naive          RMSE:", rmse(p_true[valid], p_hat_naive[valid]), " MAE:", mae(p_true[valid], p_hat_naive[valid]))
print("Moving Average RMSE:", rmse(p_true[valid], p_hat_ma[valid]),    " MAE:", mae(p_true[valid], p_hat_ma[valid]))
print("Linear Reg     RMSE:", rmse(p_true[valid], p_hat_reg[valid]),   " MAE:", mae(p_true[valid], p_hat_reg[valid]))
print("Kalman Filter  RMSE:", rmse(p_true[valid], p_hat_kf[valid]),    " MAE:", mae(p_true[valid], p_hat_kf[valid]))

# (12) 視覺化 baseline 比較
t_idx = np.arange(T)
t0, t1 = 75, 80
plt.figure(figsize=(12, 4))
plt.plot(t_idx[t0:t1], p_true[t0:t1], label="True position", linewidth=2)
plt.plot(t_idx[t0:t1], y[t0:t1], label="Observation y", linewidth=1.0, alpha=0.6)
plt.plot(t_idx[t0:t1], p_hat_naive[t0:t1], label="Naive", linestyle=":")
plt.plot(t_idx[t0:t1], p_hat_ma[t0:t1], label=f"Moving Average (k={k})", linestyle="--")
plt.plot(t_idx[t0:t1], p_hat_reg[t0:t1], label="Linear Regression", linestyle="-.")
plt.plot(t_idx[t0:t1], p_hat_kf[t0:t1], label="Kalman", linewidth=2.5)
plt.legend(); plt.title("Baselines under Noisy Observations (Position)")
plt.tight_layout(); plt.show()

# (13) 視覺化 Kalman 同時估 position & velocity
plt.figure(figsize=(12, 4))
plt.plot(t_idx[t0:t1], p_true[t0:t1], label="True position", linewidth=2)
plt.plot(t_idx[t0:t1], p_hat_kf[t0:t1], label="Kalman (position)", linewidth=2.5)
plt.plot(t_idx[t0:t1], y[t0:t1], label="Observation y", linewidth=1.0, alpha=0.45)
plt.legend(); plt.title("Kalman Filter (Position)")
plt.tight_layout(); plt.show()

plt.figure(figsize=(12, 4))
plt.plot(t_idx[t0:t1], v_true[t0:t1], label="True velocity", linewidth=2)
plt.plot(t_idx[t0:t1], v_hat_kf[t0:t1], label="Kalman velocity", linewidth=2.5)
plt.legend(); plt.title("Kalman Filter (Velocity zoom in)")
plt.tight_layout(); plt.show()

plt.figure(figsize=(12, 4))
plt.plot(t_idx, v_true, label="True velocity", linewidth=2)
plt.plot(t_idx, v_hat_kf, label="Kalman velocity", linewidth=2.5)
plt.legend(); plt.title("Kalman Filter (Velocity full)")
plt.tight_layout(); plt.show()

# (14) 敏感性分析 R / Q
R_list = [1.0, 4.0, 16.0]
Q_scale_list = [0.2, 1.0, 4.0]

# (14a) Effect of R
plt.figure(figsize=(12, 4))
plt.plot(t_idx[t0:t1], p_true[t0:t1], label="True position", linewidth=2)
for R_test in R_list:
    R_test_mat = np.array([[R_test]])
    x_hat_tmp, _, _ = kalman_filter_2d_posvel(y, F, H, Q, R_test_mat)
    plt.plot(t_idx[t0:t1], x_hat_tmp[t0:t1, 0], label=f"Kalman (R={R_test})")
plt.plot(t_idx[t0:t1], y[t0:t1], label="Observation y", linewidth=1.0, alpha=0.35)
plt.legend(); plt.title("Effect of Measurement Noise R on Kalman (Position)")
plt.tight_layout(); plt.show()

# (14b) Effect of Q scale
plt.figure(figsize=(12, 4))
plt.plot(t_idx[t0:t1], p_true[t0:t1], label="True position", linewidth=2)
for s in Q_scale_list:
    Q_test = s * Q
    x_hat_tmp, _, _ = kalman_filter_2d_posvel(y, F, H, Q_test, R)
    plt.plot(t_idx[t0:t1], x_hat_tmp[t0:t1, 0], label=f"Kalman (Q scale={s})")
plt.plot(t_idx[t0:t1], y[t0:t1], label="Observation y", linewidth=1.0, alpha=0.35)
plt.legend(); plt.title("Effect of Process Noise Q on Kalman (Position)")
plt.tight_layout(); plt.show()

# (15) Estimation Error 視覺化
plt.figure(figsize=(12,4))
plt.plot(t_idx, p_hat_naive - p_true, label="Naive error", alpha=0.7)
plt.plot(t_idx, p_hat_ma - p_true, label="MA error", alpha=0.7)
plt.plot(t_idx, p_hat_reg - p_true, label="Reg error", alpha=0.7)
plt.plot(t_idx, p_hat_kf - p_true, label="Kalman error", linewidth=2.5)
plt.axhline(0, color="black", linewidth=1)
plt.legend(); plt.title("Estimation Error (Position)")
plt.tight_layout(); plt.show()